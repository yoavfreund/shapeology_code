{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Process extracted patches\n",
    "\n",
    "This notebook takes as input the pkl files generated by process_file.py and creates binary files containing the patches, of each size, in random order.\n",
    "\n",
    "Redone with pkl files containing all sizes and not available lib/permute.py"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2019-02-01T22:31:14.583973Z",
     "start_time": "2019-02-01T22:31:14.232251Z"
    }
   },
   "outputs": [],
   "source": [
    "import pickle as pk\n",
    "import numpy as np\n",
    "from glob import glob\n",
    "%pylab inline"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2019-02-01T22:31:15.746484Z",
     "start_time": "2019-02-01T22:31:15.483606Z"
    },
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "!ls -lrt ../../data/tiles/tiles_71*\n",
    "!cat ../../data/tiles/tiles_71.log"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2019-02-01T22:31:16.539892Z",
     "start_time": "2019-02-01T22:31:16.409559Z"
    }
   },
   "outputs": [],
   "source": [
    "!ls -lrt /Users/yoavfreund/projects/shapeology/data/tiles/pickles/ | tail"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2019-02-01T22:31:17.554353Z",
     "start_time": "2019-02-01T22:31:17.291274Z"
    }
   },
   "outputs": [],
   "source": [
    "pkl_file='/Users/yoavfreund/projects/shapeology/data/tiles/pickles/tiles_71.thr.pkl'\n",
    "V=pk.load(open(pkl_file,'rb'))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2019-02-01T22:31:18.351855Z",
     "start_time": "2019-02-01T22:31:18.346704Z"
    }
   },
   "outputs": [],
   "source": [
    "len(V)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2019-02-01T22:31:19.241804Z",
     "start_time": "2019-02-01T22:31:19.235870Z"
    }
   },
   "outputs": [],
   "source": [
    "V[0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2019-02-01T23:03:29.188179Z",
     "start_time": "2019-02-01T23:02:41.953295Z"
    }
   },
   "outputs": [],
   "source": [
    "import pickle as pk\n",
    "import numpy as np\n",
    "from glob import glob\n",
    "\n",
    "import sys\n",
    "sys.path.append('../scripts/lib/')\n",
    "from os import mkdir\n",
    "\n",
    "from permute import permutator\n",
    "\n",
    "Permutators={}\n",
    "\n",
    "for pkl_file in glob('/Users/yoavfreund/projects/shapeology/data/tiles/pickles/tiles*.pkl'):\n",
    "    #print(pkl_file)\n",
    "    V=pk.load(open(pkl_file,'rb'))\n",
    "\n",
    "    for e in V:\n",
    "        size = e['padded_size']\n",
    "        tile=e['padded_patch']\n",
    "        if tile is None:\n",
    "            continue\n",
    "        asbytes = bytearray(tile.tobytes())\n",
    "        #print('size:',size,len(asbytes))\n",
    "\n",
    "        if size in Permutators:\n",
    "            Permutators[size].push(asbytes)\n",
    "        else:\n",
    "            Permutators[size] = permutator(asbytes)\n",
    "            Permutators[size].push(asbytes)\n",
    "\n",
    "for size in Permutators.keys():\n",
    "    Permutator=Permutators[size]\n",
    "    Permutator.combine('permuted-%d'%size)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2019-02-01T23:03:31.805725Z",
     "start_time": "2019-02-01T23:03:31.668186Z"
    }
   },
   "outputs": [],
   "source": [
    "!ls -lh permuted*"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2019-02-01T22:20:06.205609Z",
     "start_time": "2019-02-01T22:20:06.201707Z"
    }
   },
   "outputs": [],
   "source": [
    "P="
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2019-02-01T22:08:45.874435Z",
     "start_time": "2019-02-01T22:08:45.739665Z"
    }
   },
   "outputs": [],
   "source": [
    "!ls /tmp/permuted-0/"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "        try:\n",
    "            V=pk.load(pkl_file)\n",
    "        except:\n",
    "            print('could not load',filename)\n",
    "            continue\n",
    "        print(V[_size].shape)\n",
    "        patches=V[_size]\n",
    "\n",
    "        for i in range(patches.shape[0]):\n",
    "            j=np.random.randint(K)\n",
    "            patch=np.array(patches[i,:,:],dtype=np.float16)\n",
    "            patch.tofile(fp[j])\n",
    "            if i%1000==0:\n",
    "                print('\\r',filename,i,end='')\n",
    "\n",
    "        print('finished',k,filename,patches.shape)\n",
    "        k+=1\n",
    "        #!rm $filename\n",
    "\n",
    "    print('finished it all!!')\n",
    "    for handle in fp:\n",
    "        handle.close()\n",
    "\n",
    "    !ls -lrth $permuted_dir | wc\n",
    "\n",
    "    # read and permute each file\n",
    "    for filename in glob(permuted_dir+'/*.bin'):\n",
    "\n",
    "        D=fromfile(filename,dtype=np.float16) #,count=_size*_size)\n",
    "        pics=D.reshape([-1,_size,_size])\n",
    "\n",
    "        L=D.shape[0]\n",
    "        _order=permutation(pics.shape[0])\n",
    "        permuted_pics=pics[_order,:,:]\n",
    "        permuted_pics.tofile(filename)\n",
    "        _s=pics.shape\n",
    "        error=L - (_s[0]*_s[1]*_s[2])\n",
    "        print(filename,'shape=',pics.shape,'error=',error)\n",
    "\n",
    "    tar_filename=data_dir+'/permuted-%d'%_size+'.tgz'\n",
    "\n",
    "    !tar czvf $tar_filename $permuted_dir/\n",
    "\n",
    "    #write file to s3\n",
    "    !aws s3 mv $tar_filename s3://mousebraindata-open/MD657/permuted/\n",
    "\n",
    "    !rm -rf $permuted_dir"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "patch_red=np.array(patch,dtype=np.float32)\n",
    "imshow(patch)\n",
    "figure()\n",
    "imshow(patch_red)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "!ls -l /dev/shm/data/"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "K=200\n",
    "_size=41\n",
    "stem='/dev/shm/data/permuted'\n",
    "fp=[]\n",
    "for i in range(K):\n",
    "    fp.append(open(stem+str(i)+'.npz','bw'))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "type(fp[0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "for i in range(patches.shape[0]):\n",
    "    j=np.random.randint(K)\n",
    "    patch=patches[i,:,:]\n",
    "    patch.tofile(fp[j])\n",
    "    #imshow(patch)\n",
    "    #break\n",
    "    #print(i,j,fp_i[j])\n",
    "    if i%1000==0:\n",
    "        print('\\r',i,end='')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "for handle in fp:\n",
    "    handle.close()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "!ls -l /dev/shm/data/"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from glob import glob\n",
    "i=0\n",
    "for filename in glob('/dev/shm/data/permuted*.npz'):\n",
    "    handle=open(filename,'br')\n",
    "    while True:\n",
    "        X=np.fromfile(handle,count=_size*_size)\n",
    "        print(i,X.shape)\n",
    "        i+=1\n",
    "        if X.shape[0]<_size*_size:\n",
    "            break\n",
    "        pic=X.reshape([_size,_size])\n",
    "        imshow(pic)\n",
    "        figure()\n",
    "    print(filename,X.shape)\n",
    "    break"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "hide_input": false,
  "kernelspec": {
   "display_name": "shapeology",
   "language": "python",
   "name": "shapeology_code"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
<<<<<<< HEAD
   "version": "3.7.3"
=======
   "version": "3.7.4"
>>>>>>> 61bc08d12d650e0dd4048be542330a30965d87ff
  },
  "toc": {
   "base_numbering": 1,
   "nav_menu": {},
   "number_sections": true,
   "sideBar": true,
   "skip_h1_title": false,
   "title_cell": "Table of Contents",
   "title_sidebar": "Contents",
   "toc_cell": false,
   "toc_position": {},
   "toc_section_display": true,
   "toc_window_display": false
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
